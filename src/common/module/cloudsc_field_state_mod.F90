! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_FIELD_STATE_MOD
  ! Driver module to manage the setup and teardown of the field-based state
  USE PARKIND1,  ONLY : JPIM, JPRB
  USE YOMPHYDER, ONLY : STATE_TYPE
  USE YOECLDP,   ONLY : NCLV, YRECLDP, YRECLDP_LOAD_PARAMETERS
  USE YOMCST,    ONLY : YOMCST_LOAD_PARAMETERS
  USE YOETHF,    ONLY : YOETHF_LOAD_PARAMETERS
  USE YOEPHLI  , ONLY : YREPHLI, YREPHLI_LOAD_PARAMETERS

  USE FILE_IO_MOD, ONLY: INPUT_INITIALIZE, INPUT_FINALIZE, LOAD_SCALAR, LOAD_ARRAY
  USE EXPAND_MOD, ONLY: EXPAND, LOAD_AND_EXPAND, LOAD_AND_EXPAND_STATE, GET_OFFSETS
  USE VALIDATE_MOD, ONLY: VALIDATE
  USE CLOUDSC_MPI_MOD, ONLY: IRANK
  USE FIELD_MODULE, ONLY: FIELD_2D, FIELD_3D, FIELD_4D, FIELD_INT2D, FIELD_LOG2D

  IMPLICIT NONE

  TYPE CLOUDSC_FIELD_STATE
    INTEGER(KIND=JPIM)                   :: NPROMA, KLEV    ! Grid points and vertical levels per block
    INTEGER(KIND=JPIM)                   :: NGPTOT, NBLOCKS ! Total number of grid points and blocks
    INTEGER(KIND=JPIM)                   :: KFLDX 
    LOGICAL                              :: LDSLPHY 
    LOGICAL                              :: LDMAINCALL      ! T if main call to cloudsc
    REAL(KIND=JPRB)                      :: PTSPHY          ! Physics timestep

    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_CML(:) ! cumulative tendency used for final output
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_TMP(:) ! cumulative tendency used as input
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_LOC(:) ! local tendency from cloud scheme

    ! Underlying data buffers for AOSOA allcoated STATE_TYPE arrays
    REAL(KIND=JPRB), ALLOCATABLE :: B_CML(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_TMP(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)

    REAL(KIND=JPRB), ALLOCATABLE :: DATA_RDONLY(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: DATA_RWONLY(:,:,:,:)

    ! Storage fields to provide thread-local views
    TYPE(FIELD_2D), POINTER :: F_PRAINFRAC_TOPRFZ, F_PLSM
    TYPE(FIELD_INT2D), POINTER :: F_KTYPE
    TYPE(FIELD_LOG2D), POINTER :: F_LDCUM
    TYPE(FIELD_3D), POINTER :: F_PLCRIT_AER, F_PICRIT_AER, F_PRE_ICE, F_PCCN, F_PNICE, F_PT, F_PQ, &
     & F_PVFA, F_PVFL, F_PVFI, F_PDYNA, F_PDYNL, F_PDYNI, F_PHRSW, F_PHRLW, F_PVERVEL, F_PAP, F_PAPH, &
     & F_PLU, F_PLUDE, F_PSNDE, F_PMFU, F_PMFD, F_PA, F_PSUPSAT, F_PCOVPTOT
    TYPE(FIELD_3D), POINTER :: F_PFSQLF, F_PFSQIF, F_PFCQLNG, F_PFCQNNG, F_PFSQRF, F_PFSQSF, F_PFCQRNG, &
     & F_PFCQSNG, F_PFSQLTUR, F_PFSQITUR, F_PFPLSL, F_PFPLSN, F_PFHPSL, F_PFHPSN
    TYPE(FIELD_4D), POINTER :: F_PCLV
  CONTAINS
    PROCEDURE :: LOAD => CLOUDSC_FIELD_STATE_LOAD
    PROCEDURE :: VALIDATE => CLOUDSC_FIELD_STATE_VALIDATE
  END TYPE CLOUDSC_FIELD_STATE

  INTERFACE FIELD_INIT
    PROCEDURE FIELD_INIT_R1, FIELD_INIT_R2, FIELD_INIT_R3, FIELD_INIT_STATE
  END INTERFACE FIELD_INIT


CONTAINS

  FUNCTION CREATE_FIELD_ALLOCATE_INT2D(SHAPE, NBLOCKS) RESULT(FIELD_PTR)
    TYPE(FIELD_INT2D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1), NBLOCKS
    INTEGER(KIND=JPIM) :: B

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_INT2D(SHAPE=SHAPE, NBLOCKS=NBLOCKS, PERSISTENT=.TRUE.)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_FIELD_ALLOCATE_INT2D

  FUNCTION CREATE_FIELD_ALLOCATE_LOG2D(SHAPE, NBLOCKS) RESULT(FIELD_PTR)
    TYPE(FIELD_LOG2D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1), NBLOCKS
    INTEGER(KIND=JPIM) :: B

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_LOG2D(SHAPE=SHAPE, NBLOCKS=NBLOCKS, PERSISTENT=.TRUE.)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_FIELD_ALLOCATE_LOG2D

  FUNCTION CREATE_FIELD_ALLOCATE_2D(SHAPE, NBLOCKS, ZERO) RESULT(FIELD_PTR)
    TYPE(FIELD_2D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1), NBLOCKS
    LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
    INTEGER(KIND=JPIM) :: B

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_2D(SHAPE=SHAPE, NBLOCKS=NBLOCKS, PERSISTENT=.TRUE.)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA

    IF (PRESENT(ZERO)) THEN
      IF (ZERO) THEN
        !$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) SCHEDULE(RUNTIME)
        DO B=1, NBLOCKS
          FIELD_PTR%PTR(:,B) = 0.0_JPRB
        END DO
        !$OMP END PARALLEL DO
      END IF
    END IF
  END FUNCTION CREATE_FIELD_ALLOCATE_2D

  FUNCTION CREATE_FIELD_ALLOCATE_3D(SHAPE, NBLOCKS, ZERO) RESULT(FIELD_PTR)
    TYPE(FIELD_3D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2), NBLOCKS
    LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
    INTEGER(KIND=JPIM) :: B

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_3D(SHAPE=SHAPE, NBLOCKS=NBLOCKS, PERSISTENT=.TRUE.)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    !!! Following does however not seem required... ?
    !!! CALL FIELD_PTR%ATLAS_FIELD%DATA(FIELD_PTR%PTR)

    IF (PRESENT(ZERO)) THEN
      IF (ZERO) THEN
        !$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) SCHEDULE(RUNTIME)
        DO B=1, NBLOCKS
          FIELD_PTR%PTR(:,:,B) = 0.0_JPRB
        END DO
        !$OMP END PARALLEL DO
      END IF
    END IF
  END FUNCTION CREATE_FIELD_ALLOCATE_3D

  FUNCTION CREATE_FIELD_ALLOCATE_4D(SHAPE, NBLOCKS, ZERO) RESULT(FIELD_PTR)
    TYPE(FIELD_4D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3), NBLOCKS
    LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
    INTEGER(KIND=JPIM) :: B

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_4D(SHAPE=SHAPE, NBLOCKS=NBLOCKS, PERSISTENT=.TRUE.)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA

    IF (PRESENT(ZERO)) THEN
      IF (ZERO) THEN
        !$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) SCHEDULE(RUNTIME)
        DO B=1, NBLOCKS
          FIELD_PTR%PTR(:,:,:,B) = 0.0_JPRB
        END DO
        !$OMP END PARALLEL DO
      END IF
    END IF
  END FUNCTION CREATE_FIELD_ALLOCATE_4D

  FUNCTION CREATE_FIELD_WRAP_PACKED_2D(DATA, IDX) RESULT(FIELD_PTR)
    ! Create a single 2D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_2D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_2D(DATA=DATA, IDX=IDX)
  END FUNCTION CREATE_FIELD_WRAP_PACKED_2D

  FUNCTION CREATE_FIELD_WRAP_PACKED_3D(DATA, IDX) RESULT(FIELD_PTR)
    ! Create a single 1D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_3D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_3D(DATA=DATA, IDX=IDX)
  END FUNCTION CREATE_FIELD_WRAP_PACKED_3D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(FIELD_2D), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL EXPAND(BUFFER, FIELD%PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(FIELD_INT2D), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    INTEGER(KIND=JPIM), ALLOCATABLE :: BUFFER(:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL EXPAND(BUFFER, FIELD%PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D

    SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(FIELD_LOG2D), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    LOGICAL, ALLOCATABLE :: BUFFER(:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL EXPAND(BUFFER, FIELD%PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_3D(NAME, FIELD, NLON, NLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(FIELD_3D), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, BUFFER)
    CALL EXPAND(BUFFER, FIELD%PTR, SIZE, NPROMA, NLEV, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_3D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_4D(NAME, FIELD, NLON, NLEV, NDIM, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(FIELD_4D), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV,NDIM,  NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, NDIM, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV, NDIM))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, NDIM, BUFFER)
    CALL EXPAND(BUFFER, FIELD%PTR, SIZE, NPROMA, NLEV, NDIM, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_4D

  SUBROUTINE FIELD_INIT_R1(FIELD, NPROMA,NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,B) = 0.0_JPRB
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_R1

  SUBROUTINE FIELD_INIT_R2(FIELD, NPROMA, NLEV, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_R2

  SUBROUTINE FIELD_INIT_R3(FIELD, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NDIM, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_R3

  SUBROUTINE FIELD_INIT_STATE(STATE, BUFFER, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate empty state struct array
    !
    ! Note, the resulting AOSOA pattern is a pain to roll by hand in Fortran
    ! and could be done either via parameterized derived types or templating.
    TYPE(STATE_TYPE), ALLOCATABLE, INTENT(INOUT) :: STATE(:)
    REAL(KIND=JPRB), ALLOCATABLE, TARGET, INTENT(INOUT) :: BUFFER(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B, NFIELDS

    NFIELDS = 3+NDIM
    ALLOCATE(STATE(NBLOCKS))
    ALLOCATE(BUFFER(NPROMA, NLEV, NFIELDS, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       STATE(B)%T => BUFFER(:,:,1,B)
       STATE(B)%A => BUFFER(:,:,2,B)
       STATE(B)%Q => BUFFER(:,:,3,B)
       STATE(B)%CLD => BUFFER(:,:,4:NFIELDS,B)
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_STATE

  SUBROUTINE CLOUDSC_FIELD_STATE_LOAD(SELF, NPROMA, NGPTOT, NGPTOTG)
    ! Load reference input data via serialbox
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG

    INTEGER(KIND=JPIM) :: KLON, NFIELDS
    INTEGER(KIND=JPIM) :: START, END, SIZE

    LOGICAL :: USE_PACKED

    CALL INPUT_INITIALIZE(NAME='input')

    SELF%NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', SELF%KLEV)
    CALL LOAD_SCALAR('KFLDX', SELF%KFLDX)

    CALL GET_OFFSETS(START, END, SIZE, KLON, SELF%KLEV, NCLV, NGPTOT, NGPTOTG)

    ! Use this toggle to switch between standalone fields and bulk-allocated ones.
    USE_PACKED = .FALSE.

    IF (USE_PACKED) THEN
      ! Allocate bulk buffers for read-only input 3D fields
      NFIELDS = 24
      ALLOCATE(SELF%DATA_RDONLY(NPROMA, SELF%KLEV, NFIELDS, SELF%NBLOCKS))
      SELF%F_PT => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=1)
      SELF%F_PQ => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=2)
      SELF%F_PVFA => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=3)
      SELF%F_PVFL => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=4)
      SELF%F_PVFI => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=5)
      SELF%F_PDYNA => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=6)
      SELF%F_PDYNL => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=7)
      SELF%F_PDYNI => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=8)
      SELF%F_PHRSW => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=9)
      SELF%F_PHRLW => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=10)
      SELF%F_PVERVEL => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=11)
      SELF%F_PAP => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=12)
      SELF%F_PLU => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=13)
      SELF%F_PLUDE => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=14)
      SELF%F_PSNDE => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=15)
      SELF%F_PMFU => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=16)
      SELF%F_PMFD => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=17)
      SELF%F_PA => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=18)
      SELF%F_PSUPSAT => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=19)
      SELF%F_PLCRIT_AER => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=20)
      SELF%F_PICRIT_AER => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=21)
      SELF%F_PRE_ICE => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=22)
      SELF%F_PCCN => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=23)
      SELF%F_PNICE => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RDONLY, IDX=24)

      ! Custom fields that do not share shape or data type with the other blocks
      SELF%F_PAPH => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PLSM => CREATE_FIELD_ALLOCATE_2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS)
      SELF%F_LDCUM => CREATE_FIELD_ALLOCATE_LOG2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS)
      SELF%F_KTYPE => CREATE_FIELD_ALLOCATE_INT2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PCLV => CREATE_FIELD_ALLOCATE_4D(SHAPE=[NPROMA,SELF%KLEV,NCLV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PCOVPTOT => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PRAINFRAC_TOPRFZ => CREATE_FIELD_ALLOCATE_2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)

      ! Allocate bulk buffers for output 3D fields
      NFIELDS = 14
      CALL FIELD_INIT(SELF%DATA_RWONLY, NPROMA, SELF%KLEV+1, NFIELDS, SELF%NBLOCKS)
      SELF%F_PFSQLF => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=1)
      SELF%F_PFSQIF => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=2)
      SELF%F_PFCQLNG => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=3)
      SELF%F_PFCQNNG => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=4)
      SELF%F_PFSQRF => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=5)
      SELF%F_PFSQSF => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=6)
      SELF%F_PFCQRNG => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=7)
      SELF%F_PFCQSNG => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=8)
      SELF%F_PFSQLTUR => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=9)
      SELF%F_PFSQITUR => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=10)
      SELF%F_PFPLSL => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=11)
      SELF%F_PFPLSN => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=12)
      SELF%F_PFHPSL => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=13)
      SELF%F_PFHPSN => CREATE_FIELD_WRAP_PACKED_3D(DATA=SELF%DATA_RWONLY, IDX=14)

    ELSE
      SELF%F_PT => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PQ => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PVFA => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PVFL => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PVFI => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PDYNA => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PDYNL => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PDYNI => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PHRSW => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PHRLW => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PVERVEL => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PAP => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PLU => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PLUDE => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PSNDE => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PMFU => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PMFD => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PA => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PSUPSAT => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PLCRIT_AER => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PICRIT_AER => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PRE_ICE => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PCCN => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PNICE => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)

      ! Custom fields that do not share shape or data type with the other blocks
      SELF%F_PAPH => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PLSM => CREATE_FIELD_ALLOCATE_2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS)
      SELF%F_LDCUM => CREATE_FIELD_ALLOCATE_LOG2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS)
      SELF%F_KTYPE => CREATE_FIELD_ALLOCATE_INT2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PCLV => CREATE_FIELD_ALLOCATE_4D(SHAPE=[NPROMA,SELF%KLEV,NCLV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PCOVPTOT => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV], NBLOCKS=SELF%NBLOCKS)
      SELF%F_PRAINFRAC_TOPRFZ => CREATE_FIELD_ALLOCATE_2D(SHAPE=[NPROMA], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)

      ! Allocate bulk buffers for output 3D fields
      SELF%F_PFSQLF => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFSQIF => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFCQLNG => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFCQNNG => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFSQRF => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFSQSF => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFCQRNG => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFCQSNG => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFSQLTUR => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFSQITUR => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFPLSL => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFPLSN => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFHPSL => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
      SELF%F_PFHPSN => CREATE_FIELD_ALLOCATE_3D(SHAPE=[NPROMA,SELF%KLEV+1], NBLOCKS=SELF%NBLOCKS, ZERO=.TRUE.)
    END IF

    CALL LOAD_AND_EXPAND_FIELD_3D('PLCRIT_AER', SELF%F_PLCRIT_AER, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PICRIT_AER', SELF%F_PICRIT_AER, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PRE_ICE', SELF%F_PRE_ICE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PCCN', SELF%F_PCCN, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PNICE', SELF%F_PNICE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PT', SELF%F_PT, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PQ', SELF%F_PQ, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFA', SELF%F_PVFA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFL', SELF%F_PVFL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFI', SELF%F_PVFI, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNA', SELF%F_PDYNA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNL', SELF%F_PDYNL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNI', SELF%F_PDYNI, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRSW', SELF%F_PHRSW, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRLW', SELF%F_PHRLW, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVERVEL', SELF%F_PVERVEL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAP', SELF%F_PAP, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAPH', SELF%F_PAPH, KLON, SELF%KLEV+1, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_2D('PLSM', SELF%F_PLSM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_LOG2D('LDCUM', SELF%F_LDCUM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_INT2D('KTYPE', SELF%F_KTYPE, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLU', SELF%F_PLU, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLUDE', SELF%F_PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSNDE', SELF%F_PSNDE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFU', SELF%F_PMFU, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFD', SELF%F_PMFD, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PA', SELF%F_PA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_4D('PCLV', SELF%F_PCLV, KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSUPSAT', SELF%F_PSUPSAT, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)

    ! The STATE_TYPE arrays are tricky, as the AOSOA layout needs to be expictly
    ! unrolled at every step, and we rely on dirty hackery to do this.
    CALL FIELD_INIT(SELF%TENDENCY_LOC, SELF%B_LOC, NPROMA, SELF%KLEV, NCLV, SELF%NBLOCKS)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_CML', SELF%TENDENCY_CML, SELF%B_CML, &
         & KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_TMP', SELF%TENDENCY_TMP, SELF%B_TMP, &
         & KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)

    ! Initialize global parameters from the input file
    CALL LOAD_SCALAR('PTSPHY', SELF%PTSPHY)
    CALL LOAD_SCALAR('LDSLPHY', SELF%LDSLPHY)
    CALL LOAD_SCALAR('LDMAINCALL', SELF%LDMAINCALL)
    CALL YOMCST_LOAD_PARAMETERS()
    CALL YOETHF_LOAD_PARAMETERS()
    CALL YRECLDP_LOAD_PARAMETERS()
    CALL YREPHLI_LOAD_PARAMETERS()

    CALL INPUT_FINALIZE()

  END SUBROUTINE CLOUDSC_FIELD_STATE_LOAD

  SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE(SELF, NPROMA, NGPTOT, NGPTOTG)
    ! Validate the correctness of output against reference data
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG

    REAL(KIND=JPRB), ALLOCATABLE :: PLUDE(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PCOVPTOT(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PRAINFRAC_TOPRFZ(:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQIF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQLNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQNNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQRF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQSF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQRNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQSNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLTUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQITUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSN(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSN(:,:,:)
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_LOC(:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)

    INTEGER(KIND=JPIM) :: NBLOCKS, KLON, KLEV, KFLDX

    CALL INPUT_INITIALIZE(NAME='reference')

    NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', KLEV)
    CALL LOAD_SCALAR('KFLDX', KFLDX)

    ! Write variable validation header
    IF (IRANK == 0) THEN
      print '(1X,A20,1X,A3,5(1X,A20))', &
           & 'Variable','Dim', 'MinValue','MaxValue','AbsMaxErr','AvgAbsErr/GP','MaxRelErr-%'
    END IF

    ! Load reference data and expand to our block layout
    CALL LOAD_AND_EXPAND('PLUDE', PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PCOVPTOT', PCOVPTOT, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLF', PFSQLF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQIF', PFSQIF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQLNG', PFCQLNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQNNG', PFCQNNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQRF', PFSQRF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQSF', PFSQSF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQRNG', PFCQRNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQSNG', PFCQSNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLTUR', PFSQLTUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQITUR', PFSQITUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSL', PFPLSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSN', PFPLSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSL', PFHPSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSN', PFHPSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_LOC', TENDENCY_LOC, B_LOC, KLON, SELF%KLEV, NCLV, &
         & NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL INPUT_FINALIZE()

    ! Actual variable validation
    CALL VALIDATE('PLUDE', PLUDE, SELF%F_PLUDE%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PCOVPTOT', PCOVPTOT, SELF%F_PCOVPTOT%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, SELF%F_PRAINFRAC_TOPRFZ%PTR, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLF', PFSQLF, SELF%F_PFSQLF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQIF', PFSQIF, SELF%F_PFSQIF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQLNG', PFCQLNG, SELF%F_PFCQLNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQNNG', PFCQNNG, SELF%F_PFCQNNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQRF', PFSQRF, SELF%F_PFSQRF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQSF', PFSQSF, SELF%F_PFSQSF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQRNG', PFCQRNG, SELF%F_PFCQRNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQSNG', PFCQSNG, SELF%F_PFCQSNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLTUR', PFSQLTUR, SELF%F_PFSQLTUR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQITUR', PFSQITUR, SELF%F_PFSQITUR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSL', PFPLSL, SELF%F_PFPLSL%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSN', PFPLSN, SELF%F_PFPLSN%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSL', PFHPSL, SELF%F_PFHPSL%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSN', PFHPSN, SELF%F_PFHPSN%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    ! This is extremly hacky, but the array-of-struct-of-array layout demands it.
    CALL VALIDATE('TENDENCY_LOC%A', B_LOC(:,:,2,:), SELF%B_LOC(:,:,2,:), NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%Q', B_LOC(:,:,3,:), SELF%B_LOC(:,:,3,:), NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%T', B_LOC(:,:,1,:), SELF%B_LOC(:,:,1,:), NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%CLD', B_LOC(:,:,4:,:), SELF%B_LOC(:,:,4:,:), NPROMA, SELF%KLEV, NCLV, NGPTOT, NBLOCKS, NGPTOTG)

  END SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE

END MODULE CLOUDSC_FIELD_STATE_MOD
