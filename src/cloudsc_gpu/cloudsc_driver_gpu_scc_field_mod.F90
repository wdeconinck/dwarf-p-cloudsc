! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_DRIVER_GPU_SCC_FIELD_MOD

  USE PARKIND1, ONLY: JPIM, JPRB
  USE YOMPHYDER, ONLY: STATE_TYPE
  USE YOECLDP, ONLY : NCLV, YRECLDP, TECLDP
  USE CLOUDSC_MPI_MOD, ONLY: NUMPROC, IRANK
  USE TIMER_MOD, ONLY : PERFORMANCE_TIMER, GET_THREAD_NUM

  USE CLOUDSC_GPU_SCC_MOD, ONLY: CLOUDSC_SCC
  USE CLOUDSC_FIELD_STATE_MOD, ONLY: CLOUDSC_FIELD_STATE
  USE FIELD_MODULE, ONLY: GET_DEVICE_DATA

  IMPLICIT NONE

CONTAINS

  SUBROUTINE CLOUDSC_DRIVER_GPU_SCC_FIELD( &
     & NUMOMP, NPROMA, NLEV, NGPTOT, NGPBLKS, NGPTOTG, KFLDX, PTSPHY, &
     & FIELD_STATE, &
     & BUFFER_CML, BUFFER_TMP, BUFFER_LOC &
     & )
    ! Driver routine that invokes the optimized CLAW-based CLOUDSC GPU kernel

    INTEGER(KIND=JPIM)                                    :: NUMOMP, NPROMA, NLEV, NGPTOT, NGPBLKS, NGPTOTG
    INTEGER(KIND=JPIM)                                    :: KFLDX 
    REAL(KIND=JPRB)                                       :: PTSPHY       ! Physics timestep
    TYPE(CLOUDSC_FIELD_STATE), INTENT(INOUT)              :: FIELD_STATE
    REAL(KIND=JPRB), INTENT(INOUT) :: BUFFER_CML(NPROMA,NLEV,3+NCLV,NGPBLKS) ! Storage buffer for TENDENCY_CML
    REAL(KIND=JPRB), INTENT(INOUT) :: BUFFER_TMP(NPROMA,NLEV,3+NCLV,NGPBLKS) ! Storage buffer for TENDENCY_TMP
    REAL(KIND=JPRB), INTENT(INOUT) :: BUFFER_LOC(NPROMA,NLEV,3+NCLV,NGPBLKS) ! Storage buffer for TENDENCY_LOC

    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PT(:,:,:)       ! T at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PQ(:,:,:)       ! Q at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVFA(:,:,:)     ! CC from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVFL(:,:,:)     ! Liq from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVFI(:,:,:)     ! Ice from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PDYNA(:,:,:)    ! CC from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PDYNL(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PDYNI(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PHRSW(:,:,:)    ! Short-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PHRLW(:,:,:)    ! Long-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVERVEL(:,:,:)  ! Vertical velocity
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PAP(:,:,:)      ! Pressure on full levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PAPH(:,:,:)     ! Pressure on half levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLSM(:,:)       ! Land fraction (0-1)
    LOGICAL, POINTER, CONTIGUOUS          :: LDCUM(:,:)      ! Convection active
    INTEGER(KIND=JPIM),POINTER, CONTIGUOUS:: KTYPE(:,:)      ! Convection type 0,1,2
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLU(:,:,:)      ! Conv. condensate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLUDE(:,:,:)    ! Conv. detrained water
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PSNDE(:,:,:)    ! Conv. detrained snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PMFU(:,:,:)     ! Conv. mass flux up
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PMFD(:,:,:)     ! Conv. mass flux down
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PA(:,:,:)       ! Original Cloud fraction (t)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PCLV(:,:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PSUPSAT(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLCRIT_AER(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PICRIT_AER(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PRE_ICE(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PCCN(:,:,:)     ! liquid cloud condensation nuclei
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PNICE(:,:,:)    ! ice number concentration (cf. CCN)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PCOVPTOT(:,:,:)    ! Precip fraction
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PRAINFRAC_TOPRFZ(:,:)
    ! Flux diagnostics for DDH budget
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQLF(:,:,:)    ! Flux of liquid
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQIF(:,:,:)    ! Flux of ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQLNG(:,:,:)   ! -ve corr for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQNNG(:,:,:)   ! -ve corr for ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQRF(:,:,:)    ! Flux diagnostics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQSF(:,:,:)    !    for DDH, generic
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQRNG(:,:,:)   ! rain
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQSNG(:,:,:)   ! snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQLTUR(:,:,:)  ! liquid flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQITUR(:,:,:)  ! ice flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFPLSL(:,:,:)    ! liq+rain sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFPLSN(:,:,:)    ! ice+snow sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFHPSL(:,:,:)    ! Enthalpy flux for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFHPSN(:,:,:)    ! ice number concentration (cf. CCN)

    INTEGER(KIND=JPIM) :: JKGLO,IBL,ICEND
    TYPE(PERFORMANCE_TIMER) :: TIMER
    INTEGER(KIND=JPIM) :: TID ! thread id from 0 .. NUMOMP - 1

    ! Local copy of cloud parameters for offload
    TYPE(TECLDP) :: LOCAL_YRECLDP

    NGPBLKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
1003 format(5x,'NUMPROC=',i0,', NUMOMP=',i0,', NGPTOTG=',i0,', NPROMA=',i0,', NGPBLKS=',i0)
    if (irank == 0) then
      write(0,1003) NUMPROC,NUMOMP,NGPTOTG,NPROMA,NGPBLKS
    end if

    ! Global timer for the parallel region
    CALL TIMER%START(NUMOMP)

    ! Workaround for PGI / OpenACC oddities:
    ! Create a local copy of the parameter struct to ensure they get
    ! moved to the device the in ``acc data`` clause below
    LOCAL_YRECLDP = YRECLDP

    PT => GET_DEVICE_DATA(FIELD_STATE%F_PT)
    PQ => GET_DEVICE_DATA(FIELD_STATE%F_PQ)
    PVFA => GET_DEVICE_DATA(FIELD_STATE%F_PVFA)
    PVFL => GET_DEVICE_DATA(FIELD_STATE%F_PVFL)
    PVFI => GET_DEVICE_DATA(FIELD_STATE%F_PVFI)
    PDYNA => GET_DEVICE_DATA(FIELD_STATE%F_PDYNA)
    PDYNL => GET_DEVICE_DATA(FIELD_STATE%F_PDYNL)
    PDYNI => GET_DEVICE_DATA(FIELD_STATE%F_PDYNI)
    PHRSW => GET_DEVICE_DATA(FIELD_STATE%F_PHRSW)
    PHRLW => GET_DEVICE_DATA(FIELD_STATE%F_PHRLW)
    PVERVEL => GET_DEVICE_DATA(FIELD_STATE%F_PVERVEL)
    PAP => GET_DEVICE_DATA(FIELD_STATE%F_PAP)
    PAPH => GET_DEVICE_DATA(FIELD_STATE%F_PAPH)
    PLSM => GET_DEVICE_DATA(FIELD_STATE%F_PLSM)
    LDCUM => GET_DEVICE_DATA(FIELD_STATE%F_LDCUM)
    KTYPE => GET_DEVICE_DATA(FIELD_STATE%F_KTYPE)
    PLU => GET_DEVICE_DATA(FIELD_STATE%F_PLU)
    PLUDE => GET_DEVICE_DATA(FIELD_STATE%F_PLUDE)
    PSNDE => GET_DEVICE_DATA(FIELD_STATE%F_PSNDE)
    PMFU => GET_DEVICE_DATA(FIELD_STATE%F_PMFU)
    PMFD => GET_DEVICE_DATA(FIELD_STATE%F_PMFD)
    PA => GET_DEVICE_DATA(FIELD_STATE%F_PA)
    PCLV => GET_DEVICE_DATA(FIELD_STATE%F_PCLV)
    PSUPSAT => GET_DEVICE_DATA(FIELD_STATE%F_PSUPSAT)
    PLCRIT_AER => GET_DEVICE_DATA(FIELD_STATE%F_PLCRIT_AER)
    PICRIT_AER => GET_DEVICE_DATA(FIELD_STATE%F_PICRIT_AER)
    PRE_ICE => GET_DEVICE_DATA(FIELD_STATE%F_PRE_ICE)
    PCCN => GET_DEVICE_DATA(FIELD_STATE%F_PCCN)
    PNICE => GET_DEVICE_DATA(FIELD_STATE%F_PNICE)
    PCOVPTOT => GET_DEVICE_DATA(FIELD_STATE%F_PCOVPTOT)
    PRAINFRAC_TOPRFZ => GET_DEVICE_DATA(FIELD_STATE%F_PRAINFRAC_TOPRFZ)
    PFSQLF => GET_DEVICE_DATA(FIELD_STATE%F_PFSQLF)
    PFSQIF => GET_DEVICE_DATA(FIELD_STATE%F_PFSQIF)
    PFCQLNG => GET_DEVICE_DATA(FIELD_STATE%F_PFCQLNG)
    PFCQNNG => GET_DEVICE_DATA(FIELD_STATE%F_PFCQNNG)
    PFSQRF => GET_DEVICE_DATA(FIELD_STATE%F_PFSQRF)
    PFSQSF => GET_DEVICE_DATA(FIELD_STATE%F_PFSQSF)
    PFCQRNG => GET_DEVICE_DATA(FIELD_STATE%F_PFCQRNG)
    PFCQSNG => GET_DEVICE_DATA(FIELD_STATE%F_PFCQSNG)
    PFSQLTUR => GET_DEVICE_DATA(FIELD_STATE%F_PFSQLTUR)
    PFSQITUR => GET_DEVICE_DATA(FIELD_STATE%F_PFSQITUR)
    PFPLSL => GET_DEVICE_DATA(FIELD_STATE%F_PFPLSL)
    PFPLSN => GET_DEVICE_DATA(FIELD_STATE%F_PFPLSN)
    PFHPSL => GET_DEVICE_DATA(FIELD_STATE%F_PFHPSL)
    PFHPSN => GET_DEVICE_DATA(FIELD_STATE%F_PFHPSN)

!$acc data &
!$acc copyin(buffer_cml,buffer_tmp,yrecldp) &
!$acc copy(buffer_loc)

    ! Local timer for each thread
    TID = GET_THREAD_NUM()
    CALL TIMER%THREAD_START(TID)

!$acc parallel loop gang
    DO JKGLO=1,NGPTOT,NPROMA
       IBL=(JKGLO-1)/NPROMA+1
       ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)

       CALL CLOUDSC_SCC &
        & (1, ICEND, NPROMA, NLEV, PTSPHY,&
        & PT(:,:,IBL), PQ(:,:,IBL), &
        & BUFFER_TMP(:,:,1,IBL), BUFFER_TMP(:,:,3,IBL), BUFFER_TMP(:,:,2,IBL), BUFFER_TMP(:,:,4:8,IBL), &
        & BUFFER_LOC(:,:,1,IBL), BUFFER_LOC(:,:,3,IBL), BUFFER_LOC(:,:,2,IBL), BUFFER_LOC(:,:,4:8,IBL), &
        & PVFA(:,:,IBL), PVFL(:,:,IBL), PVFI(:,:,IBL), PDYNA(:,:,IBL), PDYNL(:,:,IBL), PDYNI(:,:,IBL), &
        & PHRSW(:,:,IBL),    PHRLW(:,:,IBL),&
        & PVERVEL(:,:,IBL),  PAP(:,:,IBL),      PAPH(:,:,IBL),&
        & PLSM(:,IBL),       LDCUM(:,IBL),      KTYPE(:,IBL), &
        & PLU(:,:,IBL),      PLUDE(:,:,IBL),    PSNDE(:,:,IBL),    PMFU(:,:,IBL),     PMFD(:,:,IBL),&
        !---prognostic fields
        & PA(:,:,IBL),       PCLV(:,:,:,IBL),   PSUPSAT(:,:,IBL),&
        !-- arrays for aerosol-cloud interactions
        & PLCRIT_AER(:,:,IBL),PICRIT_AER(:,:,IBL),&
        & PRE_ICE(:,:,IBL),&
        & PCCN(:,:,IBL),     PNICE(:,:,IBL),&
        !---diagnostic output
        & PCOVPTOT(:,:,IBL), PRAINFRAC_TOPRFZ(:,IBL),&
        !---resulting fluxes
        & PFSQLF(:,:,IBL),   PFSQIF (:,:,IBL),  PFCQNNG(:,:,IBL),  PFCQLNG(:,:,IBL),&
        & PFSQRF(:,:,IBL),   PFSQSF (:,:,IBL),  PFCQRNG(:,:,IBL),  PFCQSNG(:,:,IBL),&
        & PFSQLTUR(:,:,IBL), PFSQITUR (:,:,IBL), &
        & PFPLSL(:,:,IBL),   PFPLSN(:,:,IBL),   PFHPSL(:,:,IBL),   PFHPSN(:,:,IBL),&
        & YRECLDP=LOCAL_YRECLDP)

    ENDDO
!$acc end parallel loop
    
    CALL TIMER%THREAD_END(TID)

!$acc end data

    CALL FIELD_STATE%F_PLUDE%ENSURE_HOST()
    CALL FIELD_STATE%F_PCOVPTOT%ENSURE_HOST()
    CALL FIELD_STATE%F_PRAINFRAC_TOPRFZ%ENSURE_HOST()
    CALL FIELD_STATE%F_PFSQLF%ENSURE_HOST()
    CALL FIELD_STATE%F_PFSQIF%ENSURE_HOST()
    CALL FIELD_STATE%F_PFCQLNG%ENSURE_HOST()
    CALL FIELD_STATE%F_PFCQNNG%ENSURE_HOST()
    CALL FIELD_STATE%F_PFSQRF%ENSURE_HOST()
    CALL FIELD_STATE%F_PFSQSF%ENSURE_HOST()
    CALL FIELD_STATE%F_PFCQRNG%ENSURE_HOST()
    CALL FIELD_STATE%F_PFCQSNG%ENSURE_HOST()
    CALL FIELD_STATE%F_PFSQLTUR%ENSURE_HOST()
    CALL FIELD_STATE%F_PFSQITUR%ENSURE_HOST()
    CALL FIELD_STATE%F_PFPLSL%ENSURE_HOST()
    CALL FIELD_STATE%F_PFPLSN%ENSURE_HOST()
    CALL FIELD_STATE%F_PFHPSL%ENSURE_HOST()
    CALL FIELD_STATE%F_PFHPSN%ENSURE_HOST()

    CALL TIMER%END()

    ! On GPUs, adding block-level column totals is cumbersome and
    ! error prone, and of little value due to the large number of
    ! processing "thread teams". Instead we register the total here.
    CALL TIMER%THREAD_LOG(TID=TID, IGPC=NGPTOT)

    CALL TIMER%PRINT_PERFORMANCE(NPROMA, NGPBLKS, NGPTOT)

  END SUBROUTINE CLOUDSC_DRIVER_GPU_SCC_FIELD

END MODULE CLOUDSC_DRIVER_GPU_SCC_FIELD_MOD
